initSidebarItems({"enum":[["Algorithm",""],["Compilation","Whether to stop or continue compilation."]],"fn":[["get_attribute",""],["main","Run an analysis by calling like it rustc"],["mir_borrowck",""],["override_queries",""]],"mod":[["ast","The Rust abstract syntax tree module."],["interface",""],["mir_storage",""],["ty","Defines how the compiler represents types internally."]],"struct":[["Attribute","Metadata associated with an item."],["BodyWithBorrowckFacts","A `Body` with information computed by the borrow checker. This struct is intended to be consumed by compiler consumers."],["Config","The compiler configuration"],["DefId","A `DefId` identifies a particular definition, by combining a crate index and a def index."],["DefinitelyInitializedAnalysis",""],["ExternProviders",""],["HashMap","A hash map implemented with quadratic probing and SIMD lookup."],["LocalDefId","A LocalDefId is equivalent to a DefId with `krate == LOCAL_CRATE`. Since we encode this information in the type, we can ensure at compile time that no DefIds from upstream crates get thrown into the mix. There are quite a few cases where we know that only DefIds from the local crate are expected and a DefId from a different crate would signify a bug somewhere. This is when LocalDefId comes in handy."],["MaybeBorrowedAnalysis",""],["OurCompilerCalls",""],["Output",""],["Providers",""],["Queries",""],["Rc","A single-threaded reference-counting pointer. ‘Rc’ stands for ‘Reference Counted’."],["ReachingDefsAnalysis",""],["RefCell","A mutable memory location with dynamically checked borrow rules"],["Session","Represents the data associated with a compilation session for a single crate."]],"trait":[["FixpointEngine","Trait to be used to define an abstract-interpreation-based static analysis of a MIR body."]],"type":[["mir_borrowck",""]]});